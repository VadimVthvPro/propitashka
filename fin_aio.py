import sqlite3
from aiogram.filters import CommandStart
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums import ParseMode
import aiosqlite
import base64
import json

from translate import Translator
import matplotlib.pyplot as plt  # type: ignore
import PIL  # type: ignore
import numpy as np  # type: ignore
from tensorflow import keras  # type: ignore
from tensorflow.keras import layers  # type: ignore
from tensorflow.keras.models import Sequential  # type: ignore
import pathlib
from dotenv import load_dotenv
import os
import keyboards as kb
import asyncio
import datetime
from aiogram import Bot, Dispatcher, types, F
from aiogram.types import Message, FSInputFile, file
import tensorflow as tf  # type: ignore
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from gigachat import GigaChat
from aiogram.filters import Command



dataset_dir = pathlib.Path("food-101")
batch_size = 32
img_width = 180
img_height = 180
train_ds = tf.keras.utils.image_dataset_from_directory(
    dataset_dir,
    validation_split=0.2,
    subset="training",
    seed=123,
    image_size=(img_height, img_width),
    batch_size=batch_size)

val_ds = tf.keras.utils.image_dataset_from_directory(
    dataset_dir,
    validation_split=0.2,
    subset="validation",
    seed=123,
    image_size=(img_height, img_width),
    batch_size=batch_size)

class_names = train_ds.class_names
print(f"Class names: {class_names}")

num_classes = len(class_names)
model = Sequential([
    tf.keras.layers.Rescaling(1. / 255, input_shape=(img_height, img_width, 3)),

    tf.keras.layers.RandomFlip("horizontal", input_shape=(img_height, img_width, 3)),
    tf.keras.layers.RandomRotation(0.1),
    tf.keras.layers.RandomZoom(0.1),
    tf.keras.layers.RandomContrast(0.2),

    layers.Conv2D(16, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),

    layers.Conv2D(32, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),

    layers.Conv2D(64, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(),

    layers.Dropout(0.2),

    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(num_classes)
])

model.compile(
    optimizer='adam',
    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    metrics=['accuracy'])

model.load_weights("Foood.weights.h5")

loss, acc = model.evaluate(train_ds, verbose=2)
print("Restored model, accuracy: {:5.2f}%".format(100 * acc))



load_dotenv()
TOKEN = os.getenv('TOKEN')

def decode_credentials(encoded_str):
    decoded_bytes = base64.b64decode(encoded_str)
    decoded_str = decoded_bytes.decode('utf-8')
    client_id, client_secret = decoded_str.split(':')
    return client_id, client_secret


encoded_credentials = os.getenv('GIGA')
client_id, client_secret = decode_credentials(encoded_credentials)
GIGA = {
    'client_id': client_id,
    'client_secret': client_secret
}



credentials_str = f"{GIGA['client_id']}:{GIGA['client_secret']}"
credentials_base64 = base64.b64encode(credentials_str.encode("utf-8")).decode("utf-8")

bot = Bot(TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
storage = MemoryStorage()
dp = Dispatcher(storage=storage)


conn = sqlite3.connect('pro3.db', check_same_thread=False)
cursor = conn.cursor()


class REG(StatesGroup):
    height = State()
    age = State()
    sex = State()
    want = State()
    weight = State()
    types = State()
    length = State()
    food = State()
    food_list = State()
    food_photo = State()
    grams = State()
    food_meals = State()
    train = State()
    tren_choiser = State()
    svo = State()


async def db_table_val(user_id: int, user_age: int, user_sex: str, user_weight: float, date: str, user_aim: str,
                       imt: float, imt_str: str, cal: float, user_height: int):
    async with aiosqlite.connect('pro3.db') as conn:
        await conn.execute(
            'INSERT INTO users (user_id, user_age, user_sex, user_weight, date, user_aim, imt, imt_str, cal, user_height) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
            (user_id, user_age, user_sex, user_weight, date, user_aim, imt, imt_str, cal, user_height)
        )
        await conn.commit()


async def get_user_data(user_id: int, date: str):
    async with aiosqlite.connect('pro3.db') as conn:
        cursor = await conn.execute(
            "SELECT user_age, user_height, user_sex, user_weight, user_aim, imt, imt_str, cal FROM users WHERE user_id = ? AND date = ?",
            (user_id, date)
        )
        return await cursor.fetchone()



@dp.message(CommandStart())
async def start(message: Message):
    await message.answer_photo(
        FSInputFile(path='new_logo.jpg'),
        caption=f'–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}! –ë–æ—Ç PRO–ø–∏—Ç–∞—à–∫–∞ –ø–æ–º–æ–∂–µ—Ç —Ç–µ–±–µ –≤–µ—Å—Ç–∏ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç —Ç–≤–æ–µ–≥–æ –ø–∏—Ç–∞–Ω–∏—è –∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏.',
        reply_markup=kb.startMenu
    )


@dp.message(F.text == "–í—Ö–æ–¥")
async def entrance(message: Message, state: FSMContext):
    user_data = await get_user_data(message.from_user.id, datetime.datetime.now().strftime('%Y-%m-%d'))
    if user_data:
        height, weight, imt, imt_using_words = user_data[1], user_data[3], user_data[5], user_data[6]
        await bot.send_message(
            message.chat.id,
            text=f'{message.from_user.first_name}, —Ç–≤–æ–π –≤–µ—Å: {weight}, —Ç–≤–æ–π —Ä–æ—Å—Ç: {height}, —Ç–≤–æ–π –ò–ú–¢: {imt}, –∏ —Ç–≤–æ–π –≤–µ—Å - —ç—Ç–æ {imt_using_words}.'
        )
        await message.answer(
            '–£—Å–ø–µ—à–Ω—ã–π –≤—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É ‚úÖ. –¢–µ–ø–µ—Ä—å —Ç–µ–±–µ –¥–æ—Å—Ç—É–ø–µ–Ω –≤–µ—Å—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –±–æ—Ç–∞, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ –≤—ã–±—Ä–∞—Ç—å –∂–µ–ª–∞–µ–º—É—é —Ñ—É–Ω–∫—Ü–∏—é –≤ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ)',
            reply_markup=kb.main_menu)


    else:
        await bot.send_message(message.chat.id, text='–¢–≤–æ–∏—Ö –¥–∞–Ω–Ω—ã—Ö –≤ –±–∞–∑–µ –Ω–µ—Ç üôÅ –î–ª—è –Ω–∞—á–∞–ª–∞ –ø—Ä–æ–π–¥–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é', reply_markup=kb.reRig)


@dp.message(F.text == '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è')
async def registration(message: Message, state: FSMContext):
    await db_table_val(
        user_id=message.from_user.id,
        date=datetime.datetime.now().strftime('%Y-%m-%d'),
        user_aim="",
        imt=0.0,
        imt_str="",
        cal=0.0,
        user_sex="",
        user_height=0,
        user_weight=0.0,
        user_age=0
    )
    await state.set_state(REG.height)
    await bot.send_message(message.chat.id, text='–í–≤–µ–¥–∏ —Å–≤–æ–π —Ä–æ—Å—Ç –≤ —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–∞—Ö:')


@dp.message(REG.height)
async def height(message: Message, state: FSMContext):
    await state.update_data(height=float(message.text))
    await state.set_state(REG.age)
    await message.answer('–í–≤–µ–¥–∏ —Å–≤–æ–π –≤–æ–∑—Ä–∞—Å—Ç:')

@dp.message(REG.age)
async def age(message: Message, state: FSMContext):
    await state.update_data(age=int(message.text))
    await state.set_state(REG.sex)
    await message.answer('–í—ã–±–µ—Ä–∏ —Å–≤–æ–π –ø–æ–ª:', reply_markup=kb.sex)

@dp.message(REG.sex)
async def sex(message: Message, state: FSMContext):
    await state.update_data(sex=message.text)
    await state.set_state(REG.want)
    await message.answer('–í—ã–±–µ—Ä–∏, –∫–∞–∫ —Ö–æ—á–µ—à—å –∏–∑–º–µ–Ω–∏—Ç—å—Å—è', reply_markup=kb.want)

@dp.message(REG.want)
async def want(message: Message, state: FSMContext):
    await state.update_data(want=message.text)
    await state.set_state(REG.weight)
    await message.answer('–í–≤–µ–¥–∏ —Å–≤–æ–π –≤–µ—Å –≤ –∫–∏–ª–æ–≥—Ä–∞–º–º–∞—Ö', reply_markup=types.ReplyKeyboardRemove())

@dp.message(REG.weight)
async def wei(message: Message, state: FSMContext):
    await state.update_data(weight=message.text)
    data = await state.get_data()
    height, sex, age, weight, aim = data['height'], data['sex'], data['age'], data['weight'], data['want']


    if "," in weight:
        we1 = message.text.split(",")
        weight = int(we1[0]) + int(we1[1]) / 10 ** len(we1[1])
    else:
        weight = float(message.text)


    height, sex, age = int(height), str(sex), int(age)
    imt = round(weight / ((height / 100) ** 2), 3)
    imt_using_words = calculate_imt_description(imt)
    cal = calculate_calories(sex, weight, height, age)


    cursor.execute(
        f"UPDATE users SET user_weight = ?, imt = ?, imt_str = ?, cal = ?, user_sex = ?, user_age = ?, user_height = ?, user_aim = ? WHERE user_id = ? AND date = ?",
        (weight, imt, imt_using_words, cal, sex, age, height, aim, message.from_user.id, datetime.datetime.now().strftime('%Y-%m-%d'))
    )
    conn.commit()
    await bot.send_message(
        message.chat.id,
        text=f'{message.from_user.first_name}, —Ç–≤–æ–π –≤–µ—Å: {weight}, —Ç–≤–æ–π —Ä–æ—Å—Ç: {height}, —Ç–≤–æ–π –∏–Ω–¥–µ–∫—Å –º–∞—Å—Å—ã —Ç–µ–ª–∞: {imt}, –∏ —Ç–≤–æ–π –≤–µ—Å - —ç—Ç–æ {imt_using_words}.'
        )
    await message.answer('–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ–π–¥–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ ‚úÖ. –¢–µ–ø–µ—Ä—å —Ç–µ–±–µ –¥–æ—Å—Ç—É–ø–µ–Ω –≤–µ—Å—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –±–æ—Ç–∞, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ –≤—ã–±—Ä–∞—Ç—å –∂–µ–ª–∞–µ–º—É—é —Ñ—É–Ω–∫—Ü–∏—é –≤ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ)', reply_markup=kb.main_menu)
    await state.clear()


async def calculate_imt_description(imt):
    if round(imt) < 15:
        return '—Å–∏–ª—å–Ω–æ –º–µ–Ω—å—à–µ –Ω–æ—Ä–º—ã'
    elif round(imt) in range(14, 18):
        return '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è –º–∞—Å—Å–∞'
    elif round(imt) in range(18, 25):
        return '–ù–æ—Ä–º–∞'
    elif round(imt) in range(25, 30):
        return '–ü—Ä–µ–¥–æ–∂–∏—Ä–µ–Ω–∏–µ'
    else:
        return '–û–∂–∏—Ä–µ–Ω–∏–µ'

async def calculate_calories(sex, weight, height, age):
    if sex == '–ú—É–∂—á–∏–Ω–∞':
        return (10 * weight) + (6.25 * height) - (5 * age) + 5
    elif sex == '–ñ–µ–Ω—â–∏–Ω–∞':
        return (10 * weight) + (6.25 * height) - (5 * age) - 161
    return 0

def split_message(text, max_length=4096):
    """–†–∞–∑–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —á–∞—Å—Ç–∏ –Ω–µ –±–æ–ª–µ–µ max_length —Å–∏–º–≤–æ–ª–æ–≤."""
    return [text[i:i + max_length] for i in range(0, len(text), max_length)]

def is_not_none(item):
    return item is not None





async def generate(message, zap):
    try:
        async with GigaChat(
            credentials=os.getenv('GIGA'),
            verify_ssl_certs=False) as giga:
              pit= giga.chat(zap)
              return pit.choices[0].message.content
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {str(e)}")
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {e}"

@dp.message(F.text == '–î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏')
async def tren(message: Message, state: FSMContext):
    await bot.send_message(message.chat.id, text='–ö–∞–∫–∞—è –±—ã–ª–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞:', reply_markup=kb.tren)
    await state.set_state(REG.types)
@dp.message(REG.types)
async def tren_type(message: Message, state: FSMContext):
    await state.update_data(types=message.text)
    await state.set_state(REG.length)
    await message.answer(text = '–•–æ—Ä–æ—à–æ, –∞ –≤–≤–µ–¥–∏, —Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –¥–ª–∏–ª–∞—Å—å —Ç–≤–æ—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞:')
@dp.message(REG.length)
async def tren_len(message: Message, state: FSMContext):
    await state.update_data(length=message.text)
    data = await state.get_data()
    cursor.execute("SELECT user_weight FROM users WHERE date = ? AND user_id = ?",
                   (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
    weight = float(cursor.fetchone()[-1])
    time = int(data['length'])
    intensivity = float()
    if data['types'] == '–õ—ë–≥–∫–∞—è':
        intensivity = 2.5
    if data['types'] == '–£–º–µ—Ä–µ–Ω–Ω–∞—è':
        intensivity = 3
    if data['types'] == '–¢—è–∂—ë–ª–∞—è':
        intensivity = 3.5
    tren_cal = round((weight * intensivity * time / 24), 3)
    await bot.send_message(message.chat.id, text=f'–ü—Ä–µ–∫—Ä–∞—Å–Ω–æ! –¢—ã –∑–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É —Å–∂—ë–≥ {tren_cal} –∫–∏–ª–æ–∫–∞–ª–æ—Ä–∏–π. –¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!!',
                     reply_markup=kb.main_menu)
    async with aiosqlite.connect('pro3.db') as conn:
        await conn.execute(
    'INSERT INTO user_training_cal (user_id, date, user_train_cal, tren_time) VALUES (?, ?, ?, ?)',
                   (message.from_user.id, datetime.datetime.now().strftime('%Y-%m-%d'), tren_cal, time))
        await conn.commit()

    cursor.execute("SELECT SUM(user_train_cal) FROM user_training_cal WHERE date = ? AND user_id = ?",
            (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
    result = cursor.fetchone()[0]


    await bot.send_message(message.chat.id,
                     text=f'{message.from_user.first_name}, –∑–∞ —Å–µ–≥–æ–¥–Ω—è —Ç—ã —Å–∂—ë–≥ {result} –∫–∏–ª–æ–∫–∞–ª–æ—Ä–∏–π. –¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!!')
    await state.clear()





@dp.message(F.text == '–í–≤–µ—Å—Ç–∏ –µ–¥—É –∑–∞ –¥–µ–Ω—å')
async def food1(message: Message, state: FSMContext):
    await message.answer(text='–í—ã–±–µ—Ä–∏, –∫–∞–∫ —Ç—ã —Ö–æ—Ç–µ–ª –±—ã –¥–æ–±–∞–≤–∏—Ç—å —Å—å–µ–¥–µ–Ω–Ω—É—é –ø–∏—â—É?', reply_markup=kb.food)
    await state.set_state(REG.food)


@dp.message(REG.food)
async def foodchoise(message: Message, state: FSMContext):
    await state.update_data(food=message.text)
    await state.set_state(REG.food_photo)

    data = await state.get_data()
    if data['food'] == '–° –ø–æ–º–æ—â—å—é —Ç–µ–∫—Å—Ç–∞':
        await message.answer(text='–í–≤–µ–¥–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é –Ω–∞–∑–≤–∞–Ω–∏—è –±–ª—é–¥:', reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(REG.food_list)

    if data['food'] == '–° –ø–æ–º–æ—â—å—é —Ñ–æ—Ç–æ':
        await message.answer(text='–ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è', reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(REG.food_photo)

@dp.message(REG.food_list)
async def names(message:Message, state: FSMContext):
    await state.update_data(food_list = message.text.replace(" ", "").split(","))
    await bot.send_message(message.chat.id, text="–í–≤–µ–¥–∏, —Å–∫–æ–ª—å–∫–æ –≥—Ä–∞–º–º –±—ã–ª–æ –≤ —ç—Ç–æ–º –±–ª—é–¥–µ")
    await state.set_state(REG.grams)



@dp.message(REG.food_photo)
async def handle_photo(message:Message, state: FSMContext):
    await state.update_data(food_photo=message.photo)
    data = await state.get_data()
    photo = data['food_photo'][-1]

    await state.clear()
    name_a = []
    file_info = await bot.get_file(photo.file_id)
    downloaded_file = await bot.download_file(file_info.file_path)
 #   downloaded_file = await bot.download_file(file_path, file_info)
    save_path = 'photo.jpg'
    with open(save_path, 'wb') as new_file:
         new_file.write(downloaded_file.read())
    await bot.send_message(message.chat.id, '–§–æ—Ç–æ —Å—Ö—Ä–∞–Ω–µ–Ω–æ')
    img =  tf.keras.utils.load_img("photo.jpg", target_size=(img_height, img_width))
    img_array =  tf.keras.utils.img_to_array(img)
    img_array =  tf.expand_dims(img_array, 0)
    predictions = model.predict(img_array)
    score =  tf.nn.softmax(predictions[0])
    lol =  str(class_names[np.argmax(score)])
    translator =  Translator(from_lang="en", to_lang="ru")
    name_a.append(translator.translate(lol).title())
    await state.set_state(REG.grams)
    await bot.send_message(message.chat.id, text="–í–≤–µ–¥–∏, —Å–∫–æ–ª—å–∫–æ –≥—Ä–∞–º–º –±—ã–ª–æ –≤ —ç—Ç–æ–º –±–ª—é–¥–µ")
    await state.update_data(food_list=name_a)

@dp.message(F.text == '–ü—Ä–∏—Å–æ–µ–¥–µ–Ω–∏—Ç—å—Å—è –∫ —á–∞—Ç—É')
async def chat(message:Message):
    await message.answer(text = 'https://t.me/+QVhMA2topDgzOWVi', reply_markup=kb.main_menu)


@dp.message(F.text == '–î–æ–±–∞–≤–∏—Ç—å –≤—ã–ø–∏—Ç—ã–π —Å—Ç–∞–∫–∞–Ω—á–∏–∫ –≤–æ–¥—ã')
async def chat(message:Message):
    async with aiosqlite.connect('pro3.db') as conn:
        await conn.execute(
    'INSERT INTO water (user_id, date, count) VALUES (?, ?, ?)',
                   (message.from_user.id, datetime.datetime.now().strftime('%Y-%m-%d'), 1))
        await conn.commit()
    await message.answer(text = '–°—Ç–∞–∫–∞–Ω –¥–æ–±–∞–≤–ª–µ–Ω', reply_markup=kb.main_menu)

@dp.message(REG.grams)
async def grams(message:Message, state: FSMContext):
    await state.update_data(grams=message.text)
    data = await state.get_data()
    gram = data['grams'].split(",")
    name_a =  data['food_list']
    print(name_a, data, gram)
    for m in range(len(name_a)):
        with open('products.json') as f:
            file_content = f.read()
            foods = json.loads(file_content)
            for i in range(len(foods)):
                if foods[i]["name"] == name_a[m].title():
                    b = round(float(foods[i]["bgu"].split(',')[0]) * float(gram[m]) / 100, 3)
                    g = round(float(foods[i]["bgu"].split(',')[1]) * float(gram[m]) / 100, 3)
                    u = round(float(foods[i]["bgu"].split(',')[2]) * float(gram[m]) / 100, 3)
                    food_cal =  float(foods[i]["kcal"]) * float(gram[m]) / 100
                    print(b, g, u, food_cal)
                    cursor.execute(
                        'INSERT INTO user_pit (user_id, date, user_name_of_food, b, g, u, food_cal) VALUES (?, ?, ?, ?, ?, ?, ?)',
                        (message.from_user.id,datetime.datetime.now().strftime('%Y-%m-%d') , name_a[m], b, g, u, food_cal))
                    conn.commit()
    await bot.send_message(message.chat.id, text='–î–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∞–Ω—ã)', reply_markup=kb.main_menu)
    await state.clear()


@dp.message(F.text == '–ù–µ–¥–µ–ª—å–Ω—ã–π –ø–ª–∞–Ω –ø–∏–∞–Ω–∏—è –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫')
async def ai(message: Message, state: FSMContext):
    await message.answer( text='–ü–æ–¥–æ–∂–¥–∏ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥, –Ω–µ–π—Ä–æ—Å–µ—Ç—å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç)')

    cursor.execute(
        "SELECT user_aim, cal, user_sex, user_age, imt, user_weight, user_height FROM users WHERE date = ? AND user_id = ?",
        (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id)
    )
    aim, cal, sex, age, imt, weight, height = cursor.fetchone()
    zap_pit=  f"–ü—Ä–∏–¥—É–º–∞–π –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–≥–æ –ø–∏—Ç–∞–Ω–∏—è –Ω–∞ –Ω–µ–¥–µ–ª—é –¥–ª—è {sex},—á–µ–π —Ä–æ—Å—Ç —Ä–∞–≤–µ–Ω {height}, –≤–æ–∑—Ä–∞—Å—Ç —Ä–∞–≤–µ–Ω {age}, –∏–º—Ç —Ä–∞–≤–µ–Ω {imt} –∏ —Ü–µ–ª—å {aim}"
    plan_pit= await generate(message, zap_pit)
    zap_tren= f"–ü—Ä–∏–¥—É–º–∞–π –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ –Ω–∞ –Ω–µ–¥–µ–ª—é –¥–ª—è {sex}, —á–µ–π —Ä–æ—Å—Ç —Ä–∞–≤–µ–Ω {height}, –≤–æ–∑—Ä–∞—Å—Ç —Ä–∞–≤–µ–Ω {age},  —á–µ–π –∏–º—Ç —Ä–∞–≤–µ–Ω {imt} , —á—å—è —Ü–µ–ª—å {aim} –∏ —á–µ–π –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω –ø–∏—Ç–∞–Ω–∏—è {plan_pit}"
    plan_train = await generate(message, zap_tren)
    try:
        if plan_pit and plan_train:
            # –†–∞–∑–¥–µ–ª—è–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —á–∞—Å—Ç–∏
            for part in split_message(plan_pit):
                await bot.send_message(message.chat.id, text=part)
            for part in split_message(plan_train):
                await bot.send_message(message.chat.id, text=part)
            await message.answer(
                text='–í—ã–¥–∞–Ω–Ω—ã–µ –ø–ª–∞–Ω—ã –ø–∏—Ç–∞–Ω–∏—è –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ —è–≤–ª—è—é—Ç—Å—è –ª–∏—à—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞–Ω–∏—è–º–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ç—ã –º–æ–∂–µ—à—å –≤—ã–ø–æ–ª–Ω—è—Ç—å –ø–æ –∂–µ–ª–∞–Ω–∏—é. ',
                reply_markup=kb.main_menu)

        else:
            await bot.send_message(message.chat.id, text="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.", reply_markup=kb.main_menu)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {str(e)}")
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {e}"


@dp.message(F.text == '–ü–æ–º–æ—á—å —Å —Ä–µ—Ü–µ–ø—Ç–æ–º')
async def ai_food(message: Message, state: FSMContext):
    await message.answer(text = '–í—ã–±–µ—Ä–∏, –¥–ª—è –∫–∞–∫–æ–≥–æ –ø—Ä–∏—ë–º–∞ –ø–∏—â–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–µ—Ü–µ–ø—Ç:', reply_markup=kb.meals)
    await state.set_state(REG.food_meals)

@dp.message(REG.food_meals)
async def ai_food_meals(message: Message, state: FSMContext):
    await state.update_data(food_meals=message.text)
    data = await state.get_data()
    meal = data['food_meals']
    zap = f"–ü—Ä–∏–¥—É–º–∞–π –Ω–æ–≤—ã–π —Ä–µ—Ü–µ–ø—Ç {meal} —Å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏ –ø–æ –≥–æ—Ç–æ–≤–∫–µ"
    await message.answer( text='–ü–æ–¥–æ–∂–¥–∏ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥, –Ω–µ–π—Ä–æ—Å–µ—Ç—å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç)')
    plan_pit= await generate(message, zap)
    try:
        if plan_pit:
            # –†–∞–∑–¥–µ–ª—è–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —á–∞—Å—Ç–∏
            for part in split_message(plan_pit):
                await bot.send_message(message.chat.id, text=part, reply_markup=kb.main_menu)
        else:
            await bot.send_message(message.chat.id, text="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
                                   reply_markup=kb.main_menu)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {str(e)}")
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {e}"
    await state.clear()


@dp.message(F.text == '–ü–æ–º–æ—á—å —Å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–æ–π')
async def ai_food(message: Message, state: FSMContext):
    await message.answer(text = '–í—ã–±–µ—Ä–∏, –∫–∞–∫—É—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É —Ç—ã —Ö–æ—Ç–µ–ª –±—ã –ø—Ä–æ–≤–µ—Å—Ç–∏?', reply_markup=kb.tren_type)
    await state.set_state(REG.train)

@dp.message(REG.train)
async def train(message: Message, state: FSMContext):
    await state.update_data(train=message.text)
    data = await state.get_data()
    type_tren = data['train']
    await state.clear()
    cursor.execute("SELECT imt FROM users WHERE date = ? AND user_id = ?",
                   (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
    imt = float(cursor.fetchone()[-1])
    zap = f"–ü—Ä–∏–¥—É–º–∞–π {type_tren} —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É —Å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏ –¥–ª—è —á–µ–ª–æ–≤–µ–∫–∞ —Å –ò–ú–¢ —Ä–∞–≤–Ω—ã–º {imt}"
    await message.answer( text='–ü–æ–¥–æ–∂–¥–∏ –ø–∞—Ä—É —Å–µ–∫—É–Ω–¥, –Ω–µ–π—Ä–æ—Å–µ—Ç—å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç)')
    tren = await generate(message, zap)
    try:
        if tren:
            # –†–∞–∑–¥–µ–ª—è–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —á–∞—Å—Ç–∏
            for part in split_message(tren):
                await bot.send_message(message.chat.id, text=part, reply_markup=kb.tren_choise )
                await state.set_state(REG.tren_choiser)

        else:
            await bot.send_message(message.chat.id, text="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
                                   reply_markup=kb.main_menu)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {str(e)}")
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞: {e}"

@dp.message(REG.tren_choiser)
async def choising(message: Message, state: FSMContext):
    await state.update_data(tren_choiser=message.text)
    data = await state.get_data()
    mes = data['tren_choiser']
    await state.clear()
    if mes == '–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é':
        await message.answer(text = '–•–æ—Ä–æ—à–æ',reply_markup=kb.main_menu)
    else:
        await message.answer(text = '–§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞((', reply_markup=kb.main_menu)

@dp.message(F.text == '–í—Ö–æ–¥ –≤ –ø—Ä–æ–≥—Ä–∞–º—É')
async def ais(message: Message, state: FSMContext):
    await message.answer( text='–¢–µ–ø–µ—Ä—å —Ç—ã –º–æ–∂–µ—à—å –≤–≤–æ–¥–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ç—ã —Å–µ–≥–æ–¥–Ω—è —É–ø–æ—Ç—Ä–µ–±–∏–ª –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ç—ã —Å–µ–≥–æ–¥–Ω—è –ø—Ä–æ—à—ë–ª, –∞ –≤ –∫–æ–Ω—Ü–µ –¥–Ω—è —Ç—ã –±—É–¥–µ—à—å –ø–æ–ª—É—á–∞—Ç—å –æ—Ç—á—ë—Ç –ø–æ —Ç–≤–æ–∏–º –ë/–ñ/–£ –∑–∞ –¥–µ–Ω—å –∏ –∑–∞—Ç—Ä–∞—á–µ–Ω–Ω—ã–º –∫–∞–ª–æ—Ä–∏—è–º',reply_markup=kb.main_menu
)

@dp.message(F.text == '–°–≤–æ–¥–∫–∞')
async def svod(message: Message, state: FSMContext):
    await message.answer(text = '–í—ã–±–µ—Ä–∏, –∑–∞ –∫–∞–∫–æ–π –ø–µ—Ä–∏–æ–¥ —Ç—ã —Ö–æ—á–µ—à—å —É–≤–∏–¥–µ—Ç—å —Å–≤–æ–¥–∫—É:', reply_markup=kb.svo)
    await state.set_state(REG.svo)
@dp.message(REG.svo)
async def svodka(message: Message, state: FSMContext):
    await state.update_data(tren_choiser=message.text)
    data = await state.get_data()
    mes = data['tren_choiser']
    await state.clear()
    if mes == '–î–µ–Ω—å':
        cursor.execute("SELECT SUM(user_train_cal) FROM user_training_cal WHERE date = ? AND user_id = ?",
                       (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
        result_tren = cursor.fetchone()
        col_call_tren = result_tren[0]
        cursor.execute("SELECT SUM(food_cal) FROM user_pit WHERE date = ? AND user_id = ?",
                       (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
        result_cal_food = cursor.fetchone()
        col_cal_food = result_cal_food[0]
        cursor.execute("SELECT SUM(b) FROM user_pit WHERE date = ? AND user_id = ?",
                       (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
        result_b = cursor.fetchone()
        col_b = round(result_b[0], 3)
        cursor.execute("SELECT SUM(g) FROM user_pit WHERE date = ? AND user_id = ?",
                       (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
        result_g = cursor.fetchone()
        col_g = round(result_g[0], 3)
        cursor.execute("SELECT SUM(u) FROM user_pit WHERE date = ? AND user_id = ?",
                       (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
        result_u = cursor.fetchone()
        col_u = round(result_u[0], 3)
        cursor.execute("SELECT SUM(count) FROM water WHERE date = ? AND user_id = ?",
                       (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
        result_wat = cursor.fetchone()
        col_wat = round(result_wat[0], 3)
        cursor.execute("SELECT user_name_of_food FROM user_pit WHERE date = ? AND user_id = ?",
                       (datetime.datetime.now().strftime('%Y-%m-%d'), message.from_user.id))
        ff = ''
        result_ff = cursor.fetchall()
        for i in result_ff:
            ff += str(i[0])
            ff += ', '

        await bot.send_message(message.chat.id, text=f"""
{message.from_user.first_name}, –∑–∞ {datetime.datetime.now().strftime('%Y-%m-%d')} —É —Ç–µ–±—è —Ç–∞–∫–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:
–≤–æ –≤—Ä–µ–º—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ —Ç—ã —Å–±—Ä–æ—Å–∏–ª {round(col_call_tren, 3) if col_call_tren else 0} –∫–∏–ª–æ–∫–∞–ª–æ—Ä–∏–π, 
—Å–µ–≥–æ–¥–Ω—è—à–Ω–∏–π —Ç–≤–æ–π —Ä–∞—Ü–∏–æ–Ω —Å–æ—Å—Ç–æ—è–ª –∏–∑ {ff} –∫–∞–ª–æ—Ä–∏–π–Ω–æ—Å—Ç—å —Ä–∞—Ü–∏–æ–Ω–∞ —Å–æ—Å—Ç–∞–≤–∏–ª–∞ {round(col_cal_food, 3) if col_cal_food else 0}, 
–∑–∞ –¥–µ–Ω—å –±—ã–ª–æ —É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–æ –ë/–ñ/–£ –≤ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–∏ {col_b if col_b else 0}/{col_g if col_g else 0}/{col_u if col_u else 0} –∏ –≤—ã–ø–∏—Ç–æ {col_wat * 300 if col_wat else 0} –º–∏–ª–∏–ª–∏—Ç—Ä–æ–≤ –≤–æ–¥—ã. –Ø –≤–µ—Ä—é –≤ —Ç–≤–æ–π —É—Å–ø–µ—Ö!!""",
                         reply_markup=kb.main_menu)
    elif mes == '–ú–µ—Å—è—Ü':
        weight_month = []
        sr_b = []
        sr_g = []
        sr_u = []
        sr_cal = []
        sr_w = []
        sr_tren = []
        for i in range(1, 32):
            datee = f'{str(datetime.datetime.now().year)}-{str(datetime.datetime.now().month).zfill(2)}-{str(i).zfill(2)}'
            cursor.execute("SELECT user_weight FROM users WHERE user_id = ? AND date = ?",
                           (message.from_user.id, datee))
            weight_data = cursor.fetchall()
            if weight_data:
                weight_month.append(weight_data)
            cursor.execute("SELECT sum(b) FROM user_pit WHERE user_id = ? AND date = ?",
                           (message.from_user.id, datee))
            b_data = cursor.fetchone()
            if b_data:
                sr_b.append(b_data[0])
            cursor.execute("SELECT sum(g) FROM user_pit WHERE user_id = ? AND date = ?",
                           (message.from_user.id, datee))
            g_data = cursor.fetchone()
            if g_data:
                sr_g.append(g_data[0])
            cursor.execute("SELECT sum(u) FROM user_pit WHERE user_id = ? AND date = ?",
                           (message.from_user.id, datee))
            u_data = cursor.fetchone()
            if u_data:
                sr_u.append(u_data[0])
            cursor.execute("SELECT sum(count) FROM water WHERE user_id = ? AND date = ?",
                           (message.from_user.id, datee))
            w_data = cursor.fetchone()
            if w_data:
                sr_w.append(w_data[0])
            cursor.execute("SELECT sum(user_train_cal) FROM user_training_cal WHERE user_id = ? AND date = ?",
                           (message.from_user.id, datee))
            cal_data = cursor.fetchone()
            if cal_data:
                sr_cal.append(cal_data[0])
            cursor.execute("SELECT sum(tren_time) FROM user_training_cal WHERE user_id = ? AND date = ?",
                           (message.from_user.id, datee))
            time_data = cursor.fetchone()
            if time_data:
                sr_tren.append(time_data[0])
        if weight_month and sr_b and sr_g and sr_u and sr_cal and sr_tren and sr_w:
            weig_1 = weight_month[0][0]
            weig_2 = weight_month[-1][-1]
            new_sr_b = list(filter(is_not_none, sr_b))
            new_sr_g = list(filter(is_not_none, sr_g))
            new_sr_u = list(filter(is_not_none, sr_u))
            new_sr_w = list(filter(is_not_none, sr_w))
            new_sr_cal = list(filter(is_not_none, sr_cal))
            new_sr_tren = list(filter(is_not_none, sr_tren))
            if sum(new_sr_b) > 0:
                avg_b = round(sum(new_sr_b) / len(new_sr_b), 3)
            else:
                avg_b = 0
            if sum(new_sr_g) > 0:
                avg_g = round(sum(new_sr_g) / len(new_sr_g), 3)
            else:
                avg_g = 0
            if sum(new_sr_u) > 0:
                avg_u = round(sum(new_sr_u) / len(new_sr_u), 3)
            else:
                avg_u = 0
            if sum(new_sr_w) > 0:
                avg_w = sum(new_sr_w) / len(new_sr_w) * 300
            else:
                avg_w = 0

            avg_training_time = round(sum(new_sr_tren) / len(new_sr_tren), 3) if round(
                sum(new_sr_tren) / len(new_sr_tren), 3) else 0  # –†–∞—Å—á–µ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫
            avg_calories_burned = round(sum(new_sr_cal) / len(new_sr_cal), 3) if round(
                sum(new_sr_cal) / len(new_sr_cal), 3) else 0  # –†–∞—Å—á–µ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ —á–∏—Å–ª–∞ —Å–æ–∂–∂—ë–Ω–Ω—ã—Ö –∫–∞–ª–æ—Ä–∏–π
            await bot.send_message(message.chat.id, text=f"""{message.from_user.first_name}, –∑–∞ –º–µ—Å—è—Ü –ø—Ä–æ–∏–∑–æ—à–ª–∏ —Ç–∞–∫–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:
—Ç–≤–æ–π –≤–µ—Å –∏–∑–º–µ–Ω–∏–ª—Å—è —Å {weig_1[0]} –Ω–∞ {weig_2[0]}, 
–≤ –¥–µ–Ω—å —Ç—ã —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞–ª—Å—è {avg_training_time} –º–∏–Ω—É—Ç –∫–∞–∂–¥—ã–π –¥–µ–Ω—å, —Å–∂–∏–≥–∞—è –ø—Ä–∏ —ç—Ç–æ–º –≤ —Å—Ä–µ–¥–Ω–µ–º {avg_calories_burned} –∫–∏–ª–æ–∫–∞–ª–æ—Ä–∏–π,
–≤ –¥–µ–Ω—å —Ç–≤–æ–∏ –ë/–ñ/–£ –±—ã–ª–∏ –≤ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–∏ {avg_b}/{avg_g}/{avg_u} –∏ –≤—ã–ø–∏–≤–∞–ª–æ—Å—å –æ–∫–æ–ª–æ {avg_w} –º–∏–ª–∏–ª–∏—Ç—Ä–æ–≤ –≤–æ–¥—ã.–Ø –≤ —Ç–µ–±—è –≤–µ—Ä—é!""",
                             reply_markup=kb.main_menu)
        else:
            await bot.send_message(message.chat.id, "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —ç—Ç–æ—Ç –º–µ—Å—è—Ü.")
    elif mes == '–ì–æ–¥':
        all_data = []
        total_food_cal = 0
        total_b = 0
        total_g = 0
        total_u = 0
        total_w = 0
        weight_data_all = []
        food_months_with_data = set()

        current_date = datetime.datetime.now()

        for i in range(12):
            current_month = current_date.month - i
            current_year = current_date.year

            if current_month <= 0:
                current_year -= 1
                current_month += 12

            first_day_of_month = datetime.date(current_year, current_month, 1)
            if current_month == 12:
                last_day_of_month = datetime.date(current_year + 1, 1, 1) - datetime.timedelta(days=1)
            else:
                last_day_of_month = datetime.date(current_year, current_month + 1, 1) - datetime.timedelta(days=1)

            cursor.execute("""
                    SELECT SUM(food_cal), SUM(b), SUM(g), SUM(u)
                    FROM user_pit 
                    WHERE date >= ? AND date <= ? AND user_id = ?
                    GROUP BY strftime('%Y-%m', date)
                """, (
                first_day_of_month.strftime('%Y-%m-%d'), last_day_of_month.strftime('%Y-%m-%d'), message.from_user.id))
            result_food = cursor.fetchone()
            cursor.execute("""
                          SELECT SUM(count)
                          FROM water
                          WHERE date >= ? AND date <= ? AND user_id = ?
                          GROUP BY strftime('%Y-%m', date)
                      """, (
                first_day_of_month.strftime('%Y-%m-%d'), last_day_of_month.strftime('%Y-%m-%d'), message.from_user.id))
            result_wat = cursor.fetchone()
            if result_food and result_food[0]:
                all_data.append(result_food)
                total_food_cal += result_food[0]
                total_b += result_food[1]
                total_g += result_food[2]
                total_u += result_food[3]
                food_months_with_data.add((current_year, current_month))
            if result_wat and result_wat[0]:
                total_w += result_wat[0]
            cursor.execute("""
                    SELECT date, user_weight 
                    FROM users 
                    WHERE date >= ? AND date <= ? AND user_id = ?
                    ORDER BY date ASC
                """, (
                first_day_of_month.strftime('%Y-%m-%d'), last_day_of_month.strftime('%Y-%m-%d'), message.from_user.id))
            weight_data = cursor.fetchall()

            if weight_data:
                weight_data_all.extend(weight_data)

        if weight_data_all:
            weight_data_all.sort(key=lambda x: x[0])
            start_weight = weight_data_all[0][1]
            end_weight = weight_data_all[-1][1]
        else:
            start_weight = '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'
            end_weight = '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'

        cursor.execute("""
                SELECT AVG(user_train_cal) 
                FROM user_training_cal 
                WHERE user_id = ?
            """, (message.from_user.id,))
        result_train = cursor.fetchone()
        avg_train_cal = result_train[0] if result_train and result_train[0] else 0

        avg_food_cal = total_food_cal / len(food_months_with_data) if food_months_with_data else 0
        avg_b = round(total_b / len(food_months_with_data), 3) if food_months_with_data else 0
        avg_g = round(total_g / len(food_months_with_data), 3) if food_months_with_data else 0
        avg_u = round(total_u / len(food_months_with_data), 3) if food_months_with_data else 0
        all_data = list(filter(is_not_none, all_data))
        await bot.send_message(message.chat.id, text=f"""
–ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 12 –º–µ—Å—è—Ü–µ–≤:
—Ç–≤–æ–π –≤–µ—Å –∏–∑–º–µ–Ω–∏–ª—Å—è —Å {start_weight} –Ω–∞ {end_weight};
–≤ —Å—Ä–µ–¥–Ω–µ–º –∑–∞ –º–µ—Å—è—Ü —Ç—ã —Å–∂–∏–≥–∞–ª {avg_train_cal:.1f} –∫–∏–ª–æ–∫–∞–ª–æ—Ä–∏–π –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞—Ö;
–≤  —Å—Ä–µ–¥–Ω–µ–º —Ç–≤–æ–π —Ä–∞—Ü–∏–æ–Ω —Å–æ—Å—Ç–∞–≤–ª—è–ª {avg_food_cal:.2f} –∫–∏–ª–æ–∫–∞–ª–æ—Ä–∏–π
–≤ –Ω–∞—á–∞–ª–µ –≥–æ–¥–∞ —Ç–≤–æ–π —Ä–∞—Ü–∏–æ–Ω —Å–æ—Å—Ç–∞–≤–ª—è–ª {round(float(all_data[-1][0]), 3) if round(float(all_data[-1][0]), 3) else 0} –∫–∏–ª–æ–∫–∞–ª–∞—Ä–∏–π , –∞ –∫–æ–Ω–µ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ {round(float(all_data[0][0]), 3) if round(float(all_data[0][0]), 3) else 0} –∫–∏–ª–æ–∫–∞–ª–æ—Ä–∏–π,
—Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –ë/–ñ/–£ –≤ —Å—Ä–µ–¥–Ω–µ–º: {avg_b:.2f}/{avg_g:.2f}/{avg_u:.2f}, 
–≤ –Ω–∞—á–∞–ª–µ –≥–æ–¥–∞ —Ç–≤–æ–∏ –ë/–ñ/–£ —Å–æ—Å—Ç–∞–≤–ª—è–ª–∏ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ {round(all_data[-1][1], 3) if round(all_data[-1][1], 3) else 0}/{round(all_data[-1][2], 3) if round(all_data[-1][2], 3) else 0}/{round(all_data[-1][3], 3) if round(all_data[-1][3], 3) else 0} , –∞ –∫–æ–Ω–µ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ {round(all_data[0][1], 3) if round(all_data[0][1], 3) else 0}/{round(all_data[0][2], 3) if round(all_data[0][2], 3) else 0}/{round(all_data[0][3], 3) if round(all_data[0][3], 3) else 0},
–∏ –±—ã–ª–æ –≤—ã–ø–∏—Ç–æ –≤ —Å—Ä–µ–¥–Ω–µ–º {total_w / len(food_months_with_data) * 300 if total_w / len(food_months_with_data) * 300 else 0} –º–∏–ª–∏–ª–∏—Ç—Ä–æ–≤ –≤–æ–¥—ã –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.""",
                         reply_markup=kb.main_menu)


async def main():

    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
